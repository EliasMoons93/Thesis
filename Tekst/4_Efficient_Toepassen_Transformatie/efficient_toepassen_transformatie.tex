\chapter{Effici\"ent Toepassen Transformatie}
\label{hoofdstuk:ETT}

In dit hoofdstuk worden twee algoritmes behandeld die varianten zijn van elkaar. In beide algoritmes is het de bedoeling om een gegeven muziekstuk te transformeren tot een nieuw muziekstuk op zo een manier dat de totale consonantiescore zo hoog mogelijk is. Dit kan gebeuren door een aantal toegelaten operaties op het oorspronkelijke muziekstuk. Buiten de originele melodielijn zullen namelijk ook een aantal verschillende transformaties (zoals die beschreven zijn in onderdeel \ref{MT:afstand_vorige}) meegegeven worden aan het algoritme. Deze transformaties zullen door het algoritme gebruikt worden om het originele stuk te transformeren naar een nieuw stuk met een hogere score. Voor elke noot van de melodielijn heeft het algoritme namelijk de keuze om ofwel de noot te behouden, ofwel deze te transformeren conform een van de transformaties die meegegeven werden aan het algoritme. Het algoritme dat hier voor zorgt wordt beschreven in onderdeel \ref{ETT:algo1}. In gedeelte \ref{ETT:algo2} wordt een algoritme beschreven dat eenzelfde doel heeft maar een extra voorwaarde opgelegd krijgt. Deze voorwaarde stelt dat als met een transformatie wilt toepassen, men telkens een minimum aantal opeenvolgende noten moet transformeren met deze transformatie. 

\section{Beste sequentie}
\label{ETT:algo1}

\subsection{Doelstelling}
Het algoritme dat hier beschreven wordt is afhankelijk van twee parameters. Een eerste parameter is een originele melodielijn. De tweede parameter beschrijft een aantal transformaties (gedifini\"eerd zoals in onderdeel \ref{MT:afstand_vorige}), die gebruikt mogen worden door het algoritme. Het doel is nu om gebruik makend van enkel deze verschillende mogelijke transformaties de originele melodielijn te transformeren tot de nieuwe melodielijn die de hoogste consonantiescore oplevert. Hierbij heeft het algoritme voor elke noot in het muzikstuk twee mogelijke keuzes. Een eerste mogelijkheid is dat de noot niet getransformeerd wordt en identiek overgenomen wordt in de nieuwe melodielijn. De tweede mogelijkheid bestaat erin dat de noot ook getransformeerd mag worden, maar denk enkel volgens een van de beschikbare transformaties.

\subsection{Idee van het algoritme}
Een eerste belangrijke observatie is dat eender welke noot in het muziekstukje zelf op slechts maximaal 14 verschillende noten kan afgebeeld worden. Elke noot kan namelijk door transformatie enkel afgebeeld worden op een noot die maximaal 5 halve tonen lager ligt dan de oorspronkelijke noot en ook maximaal 6 halve tonen hoger ligt dan de originele noot (dit is een deel van de definitie van de soort transformaties die gebruikt worden in het algoritme). Er is nu echter nog een speciaal geval waarbij een transformatie tot een van de twee extreme gevallen zou leiden en deze noot dan ook nog eens geen deel zou uitmaken van de tonaard. In dat geval is het mogelijk dat de noot nog een halve toon verder afgerond wordt om terug tot op een noot te komen die in de toonaard ligt. Elke noot kan dus theoretisch gezien (na afronding) afgebeeld worden op eender welke noot die maximaal 6 halve tonen lager en maximaal 7 halve tonen hoger ligt dat zichzelf. Dit zijn in totaal 14 verschillende mogelijkheden.\\
Het belangrijkste idee van het algoritme is gebaseerd op de principes van \textit{dynamic programming} \cite{url:DP}. Bij dit algoritme komt het er op neer dat achtereenvolgens voor elke noot in het muziekstuk het best pad (en bijhorende beste score) bijgehouden zal worden voor elk van de 14 mogelijke toonhoogtes die deze noot kan aannemen in de nieuwe melodielijn. En enkel op deze optimale paden zal verder gerekend worden om te bepalen wat de beste paden zijn tot de 14 mogelijke toonhoogtes die de volgende noot in het muziekstuk kan aannemen. Dit wordt dan verder herhaald tot alle noten van de originele melodielijn overlopen zijn.

\subsection{Werking van het algoritme}
In dit onderdeel zal de werking van het algoritme beschreven worden. Als extra referentie voor de lezer is de broncode bijgevoegd in appendix \ref{Broncode:algo1}.\\ 
Het algoritme zal tijdens de uitvoering gebruik maken van 3 hulpvariabelen. De eerste twee van deze hulpvariabelen zijn eendimensionale arrays van lengte 14. De eerste array, die de naam \textit{past} meekrijgt, stelt de probabiliteiten voor van de beste paden eindigend bij alle mogelijke noten waarnaar de vorige beschouwde noot kan getransformeerd worden. De tweede array, die \textit{current} genoemd wordt, bevat de probabiliteiten van de beste paden die eindigen op de huidig beschouwde noot (of een van zijn mogelijke transformaties). De waarden in deze twee arrays, zullen in het algoritme niet de probabiliteiten zelf, maar hun logaritmen zijn, dit om het rekenwerk te vereenvoudigen. De derde hulpvariabele, \textit{matrix}, is een tweedimensionale array en heeft een dimensie van de lengte van de melodielijn op 14. Deze variabele gaat voor elke mogelijke waarde die elke noot in het muziekstukje kan aannemen, weergeven vanwaar het beste pad komt dat eindigt bij deze noot.\\
Om de betekenis van deze variabelen nog iets concreter te maken zal gebruik gemaakt worden van de volgende notatie. De letter `C' voor de toonhoogte van de huidig beschouwde noot in de originele melodielijn. De letter `P' voor de toonhoogte van de vorige noot in het originele muziekstukje. Zo zal de waarde C+3 staan voor de noot met een toonhoogte die drie halve tonen hoger ligt dan de huidige noot in het originele stukje. P-4 zal dan bijvoorbeeld staan voor de noot met een toonhoogte die 4 halve tonen lager ligt dan de vorige noot in de originele melodielijn. Verder zal, er als er in gesproken wordt over de i-de noot in het muziekstuk, de noot op positie i bedoeld worden. Zo zal de 0-de noot in het muziekstukje de eerste noot zijn, de 1-de noot zal de tweede noot van het muziekstukje zijn enzovoort.\\ 
Stel we beschouwen momenteel de n-de noot van het muziekstukje. Dan zullen volgende stellingen gelden. Op positie \textit{past[i]} zal de waarde voor de probabiliteit staan van het beste pad van n noten dat eindigt op de noot `P+i-6'. Ook zal tijdens uitvoering van het algoritme de \textit{current} array aangepast worden. Met als doelstelling: op positie \textit{current[i]} zal de waarde voor de probabiliteit berekend worden voor het beste pad van (n+1) noten dat eindigt op de noot `C+i-6'. De waarde van het element matrix[i][j] verwijst naar vanwaar het beste pad komt van (n+1) noten dat eindigt op de noot `C+j-6'. Stel nu dat matrix[i][j]=k, dan betekent dit dat het beste pad van (n+1) noten dat eindigt op noot `C+j-6', een verlenging is van het beste pad van n noten dat eindigt op noot `P+k-6'. 

\subsubsection{Initialisatie}
De eeste stap in het algoritme zal de noot op positie 1 als huidige noot bekijken en de noot op positie 0 als vorige noot. De hulpvariabelen moeten dus ge\"initialiseerd worden zodat ze daaraan voldoen. Hierdoor zal de array \textit{past} voor al zijn posities een hele lage waarde meekrijgen (-100 als logaritme van de probabiliteit in de broncode weergegeven in appendix \ref{Broncode:algo1}) behalve voor de noot op positie 6. Deze noot staat namelijk voor dezelfde noot als oorspronkelijke noot en aangezien de oorspronkelijke noot op positie 0 nooit getransformeerd wordt, zal \textit{past[6] = 0}. Dit betekent dat dat kans op het behouden van de eerste noot gelijk is aan 1. De \textit{current} array krijgt voor al zijn posities zeer lage waarden mee. De bedoeling hiervan is dat eender welk pad dat als eerste gevonden wordt dat voortgaat op de vorige noot een hogere probabiliteit zal hebben dan deze waarde. Tot slot zal ook elke waarde van \textit{matrix} op een arbitraire startwaarde 0 gezet worden. De waarde die hier in het begin gezet wordt is van geen belang, aangezien deze waarden toch overschreven zullen worden wanneer de beste paden berekend worden.

\subsubsection{Een stap in het algoritme}
Voor elke noot in het muziekstukje, beginnend vanaf de noot op positie 1, zal nu het volgende uitegevoerd worden. Stel ook dat we momenteel als huidige noot, de noot op positie n beschowen.\\ 
Allereerst gaan we op \textit{current[6]} de waarde zetten van het beste pad dat de huidige noot niet transformeert. Om dit te doen gaan we kijken naar de probabiliteiten van de beste paden die eindigen op alle 14 mogelijke noten die als vorige noot zouden kunnen doorgaan. Deze probabiliteiten staan uiteraard gewoon in \textit{past}. Voor elk element \textit{past[i]} wordt nu zijn waarde bij de afstandsprobabiliteit ten opzichte van de huidig beschouwde noot opgeteld. Als deze waarde hoger is dan de huidige beste waarde van \textit{current[6]}, dan wordt de waarde van \textit{current[6]} overschreven en wordt de waarde \textit{matrix[n][6]} op i gezet.
Als tweede stap gaan we voor elke mogelijk transformatie kijken naar welke noot de noot op `P+i-6' de noot huidige noot gaat afbeelden. En dit voor alle 14 mogelijke vorige noten. Stel nu dat de noot `P-i+6' de huidig beschouwde noot afbeeldt op noot `C+j-6'. Als nu de de som van \textit{past[i]} en de afstandsprobabiliteit tussen deze twee noten groter is dan de huidige waarde \textit{current[j]}, dan zal deze waarde overschreven worden. Alsook zal \textit{matrix[n][j]} gelijk gesteld worden aan i. Dit aangezien het nieuwe meest waarschijnlijke pad dat gevonden is dat eindigt op `C+j-6', komt van de noot `P+i-6'.\\
Wanneer dit uitgevoerd is, bevat \textit{current} de probabiliteiten van de beste paden van lengte (n+1) die eindigen op de 14 mogelijke toonhoogtes waarop de huidig beschouwde noot kan afgebeeld worden.
Het enige wat nu nog rest is om de waarden van \textit{current} over te zetten naar \textit{past}. En om \textit{current} daarna terug te initialiseren op zeer lager waarden. Dit zodat de arrays klaar zijn voor het beschouwen van de volgende noot in het muziekstukje. 

\subsubsection{Extractie van het beste pad}
Na uitvoeren van het vorige gedeelte voor elke noot in het muziekstukje zal \textit{past} de probabiliteiten bevatten van de beste paden voor elk van de 14 mogelijke eindnoten van het geheel van het nieuwe muziekstukje. Als eerste zal er dus gekeken worden welke van deze 14 toonhoogtes het meest waarschijnlijke pad heeft. Dit pad is het pad dat we zoeken in dit algoritme. Het enige wat nu nog rest is om vanaf dit punt dat pad te reconstueren. Dit gebeurt met behulp van de \textit{matrix} array. Beginnen bij de laatste noot en zo opschuivend terug naar voor wordt hiervoor het volgende gedaan. Stel we zitten bij noot n. Noem `C+i-6' de toonhoogte van de huidige noot die in dit beste pad zit. Noem nu \textit{matrix[n][i]} = j. Dan is de vorige noot van het optimale pad de noot met als toonhoogte `P+j-6', waarbij P de toonhoogte is van de overeenkomstige noot in het originele muziekstuk. \textit{matrix[n-1][j]} geeft dan weer aanleiding tot de noot die daarvoor staat in het optimale pad, enzovoort. Op deze manier kan het volledige optimale pad weer gereconstrueerd worden.

\subsection{Performantie en geheugencomplexiteit}
De parameters waarvan het algoritme afhankelijk is, zijn de lengte van de melodielijn in de invoer en ook het aantal transformaties (in het voorbeeld beschreven in appendix \ref{Broncode:algo1} wordt gebruik gemaakt van slechts 2 transformaties, maar het algoritme werkt voor eender welk aantal transformaties dat gedefini\"eerd wordt).\\ 
De snelheid van het algoritme is lineair afhankelijk van beide van deze parameters. Indien de lengte van het originele melodietje met een factor f omhoog gaat en de rest constant blijft dan gaat ook het aantal stappen in het algoritme met een factor f omhoog. Het rekenwerk per stap blijft echter gelijk. Wanneer het aantal transformaties met een factor f omhoog gaat en de rest constant blijft, dan zal het aantal stappen onveranderd blijven. Het rekenwerk per stap gaat wel met een factor f omhoog (op het constante rekenwerk per stap van het `niet transformeren' na).\\
Het geheugen dat nodig is voor de uitvoer van het algoritme is lineair afhankelijk van de lengte van de originele melodie. Dit komt omdat de \textit{matrix} array als een van zijn dimensies deze lengte heeft. Wanneer de lengte van het originele stukje met een factor f omhoog gaat, zal de grootte van deze array dus ook met een factor f omhoog gaan. De grootte van de andere twee gebruikte arrays tijdens de uitvoer van het algoritme is onveranderlijk ten opzichte van die lengte. Maar in het total geheugengebruik is de \textit{matrix} array dominant aangezien deze zo veel groter is. Het aantal gebruikte transformaties heeft geen effect op het geheugengebruik van het algoritme.

\section{Beste sequentie met minimum transformatie lengte}
\label{ETT:algo2}

\subsection{Doelstelling}
Het algoritme dat in dit onderdeel beschreven wordt heeft dezelfde doelstelling als het algoritme beschreven in onderdeel \ref{ETT:algo1}. Enkel wordt dit algoritme aan nog een extra restrictie onderworpen. Zo zal dit algoritme afhankelijk zijn van drie parameters. De eerste twee parameters zijn een originele melodielijn en een aantal toegelaten transformaties. Als extra parameter is dit algoritme nog afhankelijk van een opgegeven minimum transformatie lengte. Dit betekent dat het algoritme enkel een deel van de originele melodielijn mag transformeren als hij voor minstens dit opgegeven aantal opeenvolgende noten dezelfde transformatie toepast. Er zijn een aantal overeenkomsten tussen dit algoritme en het algoritme beschreven in sectie \ref{ETT:algo1}. Bij het bespreken van deze overeenkomsten zal er verwezen worden naar overeenkomstige delen in dat hoofdstuk. Daar waar dit algoritme verschilt van het vorige zal een volledige uitleg gegeven worden.

\subsection{Idee van het algoritme}
Ook nu zal er gebruik gemaakt worden van de principes van \textit{dynamic programming}. Dit zal enkel op een verschillende manier gebeuren dan bij het vorige algoritme, aangezien de opgegeven minimumlengte verhindert om eenzelfde data representatie te gebruiken, waarom dit precies noodzakelijk is wordt verder in de tekst nog verduidelijkt. Het idee van dit algoritme bestaat erin om elke noot van het muziekstukje chronologisch te overlopen. En bij elke noot uit het originele stuk zijn er dan een aantal mogelijkheden om het beste pad te bepalen dat eindigt op een van de 14 mogelijke noten waarin de originele noot kan getransformeerd worden. Als in het vervolg van de tekst gesproken wordt over een `geldig pad', dan wordt hier een pad mee bedoeld dat de regels van de minimumlengte voor transformatie en de mogelijke transformaties respecteert. De parameter die voor de minimum transformatie lengte staat wordt met `ML' aangeduid. Een eerste mogelijkheid voor zo een optimaal pad is de uitbreiding van eender welk optimaal pad dat eindigt bij de vorige noot met het behouden van de huidige noot. Een tweede mogelijkheid is het uitbreiden van een optimaal pad dat geldig is, eindigt op de vorige noot en eindigt met transformatie f (en dus minstens zijn ML laatste noten met die transformatie is bekomen aangezien we al stelden dat het pad geldig was) uit te breiden met weer dezelfde transformatie f. Tot slot is er ook nog de mogelijkheid om eender welk optimaal en geldig pad van lengte ML korter dan het huidige uit te breiden met ML keer dezelfde transformatie. Op deze manier kunnen alle optimale paden bekomen worden die aan de vooropgestelde eisen voldoen.

\subsection{Werking van het algoritme}

\subsubsection{Initialisatie}
\subsubsection{Een stap in het algoritme}
\subsubsection{Extractie van het beste pad}

\subsection{Performantie en geheugencomplexiteit}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "masterproef"
%%% End: 
